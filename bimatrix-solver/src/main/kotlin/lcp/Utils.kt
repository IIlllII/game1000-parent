package lcp

import java.io.*
import java.math.BigInteger
import java.util.*

object BigIntegerUtils {

    fun lcm(a: BigInteger, b: BigInteger): BigInteger {
        val u = a.gcd(b)
        val v = a.divide(u)   /* v=a/u */
        return v.multiply(b).abs()
    }

    /* find largest gcd of p[0]..p[n-1] and divide through */
    fun reducearray(p: Array<BigInteger>) {
        var i = 0

        while (i < p.size && zero(p[i]))
            i++
        if (i == p.size)
            return

        var divisor = p[i].abs()
        i++

        while (i < p.size) {
            if (!zero(p[i])) {
                divisor = divisor.gcd(p[i].abs())
            }
            i++
        }

        i = 0
        while (i < p.size) {
            if (!zero(p[i]))
                p[i] = p[i].divide(divisor)
            i++
        }
    }

    /**
     * Compare the product of Na*Nb to Nc*Nd
     * @return
     * +1 if Na*Nb > Nc*Nd,
     * -1 if Na*Nb < Nc*Nd,
     * 0 if Na*Nb = Nc*Nd
     */
    fun comprod(Na: BigInteger, Nb: BigInteger, Nc: BigInteger, Nd: BigInteger): Int {
        val mc = Na.multiply(Nb).subtract(Nc.multiply(Nd))
        if (positive(mc))
            return 1
        return if (negative(mc)) -1 else 0
    }

    fun positive(a: BigInteger): Boolean {
        return a.compareTo(BigInteger.ZERO) > 0
    }

    fun negative(a: BigInteger): Boolean {
        return a.compareTo(BigInteger.ZERO) < 0
    }

    fun zero(a: BigInteger): Boolean {
        return a.compareTo(BigInteger.ZERO) == 0
    }

    fun one(a: BigInteger): Boolean {
        return a.compareTo(BigInteger.ONE) == 0
    }

    fun greater(left: BigInteger, right: BigInteger): Boolean {
        return left.compareTo(right) > 0
    }
}


class ColumnTextWriter {

    /* contains in succession all strings generated by  colpr
	 * Each array is one row (ended by using newRow())
	 * Does not include current active row (currline)
	 */
    private var buf: MutableList<List<String>> = ArrayList()

    private val ncols = 0                                        /* max number of columns               			*/
    private val colwidth = ArrayList<Int>()    /* [0..ncols-1]  output widths         			*/
    private val widthsign = ArrayList<Int>()    /* -1 for left, 1 for right alignment  			*/
    private var currcol = 0
    private var currline: MutableList<String> = ArrayList()

    private var clean: String? = null

    /*private void reset() {
    	buf.clear();
        ncols = 0;
        colwidth.clear();
        widthsign.clear();
        currcol = 0;
        currline.clear();
    }*/

    fun writeCol(i: Int) {
        writeCol(i.toString())
    }

    /* making column  c  in  0..ncols-1  left-adjusted      */
    fun alignLeft(c: Int) {
        clean = null
        widthsign[c] = -1
    }

    /* making next column written to left-adjusted      */
    fun alignLeft() {
        if (currcol == 0) return
        alignLeft(currcol - 1)
    }

    @JvmOverloads
    fun alignRight(c: Int = currcol) {
        clean = null
        widthsign[c] = 1
    }

    private fun printRow(output: StringWriter, s: List<String>) {
        for (j in s.indices) {
            val width = colwidth[j] * widthsign[j]
            if (width != 0) {
                val format = String.format("%%%ds", width)
                output.write(String.format(format, s[j]))

                if (j < s.size - 1)
                /* avoid trailing blanks in line        */
                    output.write(" ")        /* more sophisticated spacing possible  */
            } else {
                //System.out.println("column " + j + " is width 0");
            }
        }
    }

    private fun print(output: StringWriter) {
        for (line in buf) {
            printRow(output, line)
            output.write(newline)
        }
        printRow(output, currline) //Do we want a newline here?
        //reset();
    }

    override fun toString(): String {
        if (clean == null) {
            val output = StringWriter()
            print(output)
            clean = output.toString()
        }
        return clean ?: "null"
    }

    fun writeCol(s: String) {
        clean = null
        val w = s.length
        if (currcol == colwidth.size) {
            colwidth.add(w)
            widthsign.add(1)
        } else if (colwidth[currcol] < w) {
            colwidth[currcol] = w
        }

        currline.add(s)

        ++currcol
    }

    fun endRow() {
        clean = null
        buf.add(currline)
        currcol = 0
        currline = ArrayList(ncols)
    }

    fun sortBy(col: Int, fromRow: Int) {
        clean = null
        val subBuf = buf.subList(fromRow, buf.size)
        buf = buf.subList(0, fromRow)
        Collections.sort(subBuf, Comparator { a, b ->
            val aStr = a[col]
            val bStr = b[col]
            try {
                return@Comparator Integer.valueOf(aStr).compareTo(Integer.valueOf(bStr))
            } catch (ex: NumberFormatException) {
                return@Comparator aStr.compareTo(bStr)
            }
        })
        buf.addAll(subBuf)
    }

    companion object {
        private val newline = System.getProperty("line.separator")

        // old style static methods
        private val instance = ColumnTextWriter()
        private val sysout = BufferedWriter(OutputStreamWriter(System.out))

        fun colpr(s: String) {
            instance.writeCol(s)
        }

        fun colipr(i: Int) {
            instance.writeCol(i)
        }

        fun colnl() {
            instance.endRow()
        }

        fun colleft(n: Int) {
            instance.alignLeft(n)
        }

        @Throws(IOException::class)
        fun colout() {
            sysout.write(instance.toString()!!)
        }

        @Throws(IOException::class)
        fun colout(output: Writer) {
            output.write(instance.toString()!!)
        }
    }
}
